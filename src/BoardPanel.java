import javax.swing.*;
import java.awt.*;
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;
import java.util.*;
import java.util.List;

class BoardPanel extends JPanel {
    private Board board;
    private List<Player> players;
    private Image boardImage;
    private Point[] nodeLocations;

    public BoardPanel(Board board) {
        this.board = board;
        this.players = new ArrayList<>();

        try {
            boardImage = ImageIO.read(new File("board_bg.png"));
            System.out.println("✓ Board image loaded in BoardPanel");
        } catch (IOException e) {
            System.err.println("✗ ERROR: Cannot load board_bg.png in BoardPanel");
            e.printStackTrace();
        }

        setPreferredSize(new Dimension(1100, 750));
        setBackground(new Color(44, 62, 80));

        initNodeLocations();
    }

    private void initNodeLocations() {
        // Calibrated node locations for 74-node board
        // Generated by CalibrationMode on 2025-12-04 03:51:47
        nodeLocations = new Point[75];

        nodeLocations[ 1] = new Point( 960,   85);
        nodeLocations[ 2] = new Point( 910,  110);
        nodeLocations[ 3] = new Point( 854,  123);
        nodeLocations[ 4] = new Point( 806,   97);
        nodeLocations[ 5] = new Point( 759,   69);
        nodeLocations[ 6] = new Point( 699,   61);
        nodeLocations[ 7] = new Point( 649,   85);
        nodeLocations[ 8] = new Point( 706,  106);
        nodeLocations[ 9] = new Point( 665,  137);
        nodeLocations[10] = new Point( 636,  171);
        nodeLocations[11] = new Point( 693,  193);
        nodeLocations[12] = new Point( 761,  207);
        nodeLocations[13] = new Point( 834,  203);
        nodeLocations[14] = new Point( 902,  191);
        nodeLocations[15] = new Point( 968,  173);
        nodeLocations[16] = new Point(1032,  155);
        nodeLocations[17] = new Point(1103,  145);
        nodeLocations[18] = new Point(1130,  181);
        nodeLocations[19] = new Point(1153,  214);
        nodeLocations[20] = new Point(1147,  249);
        nodeLocations[21] = new Point(1080,  265);
        nodeLocations[22] = new Point(1009,  278);
        nodeLocations[23] = new Point( 934,  272);
        nodeLocations[24] = new Point( 857,  274);
        nodeLocations[25] = new Point( 797,  297);
        nodeLocations[26] = new Point( 802,  333);
        nodeLocations[27] = new Point( 872,  345);
        nodeLocations[28] = new Point( 947,  343);
        nodeLocations[29] = new Point(1021,  339);
        nodeLocations[30] = new Point(1087,  356);
        nodeLocations[31] = new Point(1063,  392);
        nodeLocations[32] = new Point(1016,  421);
        nodeLocations[33] = new Point( 952,  438);
        nodeLocations[34] = new Point( 877,  435);
        nodeLocations[35] = new Point( 806,  423);
        nodeLocations[36] = new Point( 732,  429);
        nodeLocations[37] = new Point( 660,  439);
        nodeLocations[38] = new Point( 587,  448);
        nodeLocations[39] = new Point( 512,  448);
        nodeLocations[40] = new Point( 484,  415);
        nodeLocations[41] = new Point( 536,  388);
        nodeLocations[42] = new Point( 578,  358);
        nodeLocations[43] = new Point( 618,  327);
        nodeLocations[44] = new Point( 616,  291);
        nodeLocations[45] = new Point( 546,  278);
        nodeLocations[46] = new Point( 473,  289);
        nodeLocations[47] = new Point( 427,  319);
        nodeLocations[48] = new Point( 386,  349);
        nodeLocations[49] = new Point( 351,  382);
        nodeLocations[50] = new Point( 318,  415);
        nodeLocations[51] = new Point( 275,  445);
        nodeLocations[52] = new Point( 203,  455);
        nodeLocations[53] = new Point( 140,  434);
        nodeLocations[54] = new Point( 156,  398);
        nodeLocations[55] = new Point( 190,  365);
        nodeLocations[56] = new Point( 189,  328);
        nodeLocations[57] = new Point( 156,  294);
        nodeLocations[58] = new Point( 132,  260);
        nodeLocations[59] = new Point( 172,  230);
        nodeLocations[60] = new Point( 246,  228);
        nodeLocations[61] = new Point( 319,  223);
        nodeLocations[62] = new Point( 388,  209);
        nodeLocations[63] = new Point( 451,  193);
        nodeLocations[64] = new Point( 506,  169);
        nodeLocations[65] = new Point( 534,  135);
        nodeLocations[66] = new Point( 559,  101);
        nodeLocations[67] = new Point( 498,   79);
        nodeLocations[68] = new Point( 422,   80);
        nodeLocations[69] = new Point( 363,  102);
        nodeLocations[70] = new Point( 312,  129);
        nodeLocations[71] = new Point( 257,  155);
        nodeLocations[72] = new Point( 185,  162);
        nodeLocations[73] = new Point( 151,  132);
        nodeLocations[74] = new Point( 109,   99);
    }

    public void setPlayers(List<Player> players) {
        this.players = players;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Draw board image
        if (boardImage != null) {
            g2d.drawImage(boardImage, 0, 0, getWidth(), getHeight(), this);
        } else {
            g2d.setColor(Color.LIGHT_GRAY);
            g2d.fillRect(0, 0, getWidth(), getHeight());
            g2d.setColor(Color.RED);
            g2d.setFont(new Font("Arial", Font.BOLD, 20));
            g2d.drawString("❌ ERROR: board_bg.png not found!", 50, getHeight() / 2);
            return;
        }

        drawPlayers(g2d);
    }

    private void drawPlayers(Graphics2D g2d) {
        Map<Integer, List<Player>> playersByPosition = new HashMap<>();

        // Group players by position
        for (Player player : players) {
            int pos = player.getPosition();
            playersByPosition.putIfAbsent(pos, new ArrayList<>());
            playersByPosition.get(pos).add(player);
        }

        // Draw players at each position
        for (Map.Entry<Integer, List<Player>> entry : playersByPosition.entrySet()) {
            int position = entry.getKey();
            List<Player> playersAtPos = entry.getValue();

            Point pixelPos = getPixelPosition(position);
            int baseX = pixelPos.x;
            int baseY = pixelPos.y;

            int numPlayers = playersAtPos.size();
            for (int i = 0; i < numPlayers; i++) {
                Player player = playersAtPos.get(i);

                // Calculate offset for multiple players at same position
                int offsetX = 0, offsetY = 0;
                if (numPlayers > 1) {
                    double angle = 2 * Math.PI * i / numPlayers;
                    offsetX = (int) (18 * Math.cos(angle));
                    offsetY = (int) (18 * Math.sin(angle));
                }

                int px = baseX + offsetX;
                int py = baseY + offsetY;

                // Draw shadow
                g2d.setColor(new Color(0, 0, 0, 80));
                g2d.fillOval(px - 16, py - 16, 34, 34);

                // Draw player circle
                g2d.setColor(player.getColor());
                g2d.fillOval(px - 15, py - 15, 30, 30);

                // Draw white border
                g2d.setColor(Color.WHITE);
                g2d.setStroke(new BasicStroke(2.5f));
                g2d.drawOval(px - 15, py - 15, 30, 30);

                // Draw player initial
                g2d.setColor(Color.WHITE);
                g2d.setFont(new Font("Arial", Font.BOLD, 14));
                String initial = player.getName().substring(0, 1).toUpperCase();
                FontMetrics fm = g2d.getFontMetrics();
                int textWidth = fm.stringWidth(initial);
                int textHeight = fm.getAscent();
                g2d.drawString(initial, px - textWidth / 2, py + textHeight / 2 - 2);
            }
        }
    }

    private Point getPixelPosition(int logicalPos) {
        // Boundary check
        if (logicalPos < 1) {
            logicalPos = 1;
        }
        if (logicalPos >= nodeLocations.length) {
            logicalPos = nodeLocations.length - 1;
        }

        // Return mapped position
        if (nodeLocations[logicalPos] != null) {
            return nodeLocations[logicalPos];
        }

        // Fallback to default position
        System.err.println("⚠️  Node " + logicalPos + " has no mapped position!");
        return new Point(100, 100);
    }
}